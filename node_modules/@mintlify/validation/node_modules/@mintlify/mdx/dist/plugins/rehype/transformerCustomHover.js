export const CUSTOM_HOVER_CLASS_NAME = 'custom-hover';
export const CUSTOM_HOVER_TOOLTIP_CLASS_NAME = 'custom-hover-tooltip';
export function transformerCustomHover({
  className = CUSTOM_HOVER_CLASS_NAME,
  enableLinks = true,
  linkPrefix = '',
  maxTooltipWidth = 300,
} = {}) {
  return {
    name: 'custom-hover',
    preprocess(code) {
      return code;
    },
    code(node) {
      const code = this.source;
      if (!code) return;
      const annotations = parseHoverAnnotations(code);
      if (annotations.length === 0) {
        return;
      }
      const spanElements = node.children.filter(
        (child) => child.type === 'element' && child.tagName === 'span'
      );
      spanElements.forEach((lineElement, spanIndex) => {
        const annotation = annotations.find((ann) => ann.lineIndex === spanIndex);
        if (!annotation) {
          return;
        }
        addHoverToLine(lineElement, annotation, {
          className,
          enableLinks,
          linkPrefix,
          maxTooltipWidth,
        });
      });
    },
  };
}
function parseHoverAnnotations(code) {
  const lines = code.split('\n');
  const annotations = [];
  for (let i = 0; i < lines.length; i++) {
    const currentLine = lines[i];
    if (!currentLine) continue;
    const line = currentLine.trim();
    const singleLineMatch = line.match(/\/\/\s*@hover:\s*(.+)$/);
    if (singleLineMatch && singleLineMatch[1]) {
      const content = singleLineMatch[1];
      const { processedContent, hasLinks, links } = processLinks(content);
      const targetLineIndex = findTargetLine(lines, i + 1);
      if (targetLineIndex !== -1) {
        annotations.push({
          content: processedContent,
          lineIndex: targetLineIndex,
          hasLinks,
          links,
        });
      }
      continue;
    }
    const multiLineStart = line.match(/\/\/\s*@hover-multi:\s*(.*)$/);
    if (multiLineStart) {
      const contentLines = [];
      if (multiLineStart[1]) {
        contentLines.push(multiLineStart[1]);
      }
      let j = i + 1;
      let foundEnd = false;
      while (j < lines.length) {
        const lineAtJ = lines[j];
        if (!lineAtJ) {
          j++;
          continue;
        }
        const currentLine = lineAtJ.trim();
        if (currentLine.match(/\/\/\s*@hover-end\s*$/)) {
          foundEnd = true;
          break;
        }
        const contentMatch = currentLine.match(/\/\/\s*(.*)$/);
        if (contentMatch && contentMatch[1] !== undefined) {
          contentLines.push(contentMatch[1]);
        } else {
          break;
        }
        j++;
      }
      if (foundEnd && contentLines.length > 0) {
        const fullContent = contentLines.join('\n');
        const { processedContent, hasLinks, links } = processLinks(fullContent);
        const targetLineIndex = findTargetLine(lines, j + 1);
        if (targetLineIndex !== -1) {
          annotations.push({
            content: processedContent,
            lineIndex: targetLineIndex,
            hasLinks,
            links,
          });
        }
        i = j;
      }
    }
  }
  return annotations;
}
function findTargetLine(lines, startIndex) {
  for (let i = startIndex; i < lines.length; i++) {
    const currentLine = lines[i];
    if (!currentLine) continue;
    const line = currentLine.trim();
    if (line && !line.startsWith('//') && !line.startsWith('/*')) {
      return i;
    }
  }
  return -1;
}
function processLinks(content) {
  const links = [];
  const linkRegex = /\[([^\]]+)\]\(#([^)]+)\)/g;
  let match;
  while ((match = linkRegex.exec(content)) !== null) {
    if (match[1] && match[2]) {
      links.push({
        text: match[1],
        anchor: match[2],
      });
    }
  }
  const processedContent = content.replace(
    linkRegex,
    '<span class="hover-link" data-anchor="$2">$1</span>'
  );
  return {
    processedContent,
    hasLinks: links.length > 0,
    links,
  };
}
function addHoverToLine(lineElement, annotation, options) {
  const { className, enableLinks, linkPrefix } = options;
  if (!lineElement.properties.className) {
    lineElement.properties.className = [];
  }
  const classNames = Array.isArray(lineElement.properties.className)
    ? lineElement.properties.className
    : lineElement.properties.className
      ? [lineElement.properties.className]
      : [];
  classNames.push(className);
  lineElement.properties.className = classNames.filter(
    (c) => typeof c === 'string' || typeof c === 'number'
  );
  lineElement.properties['data-hover-content'] = annotation.content;
  if (annotation.hasLinks && enableLinks) {
    lineElement.properties['data-hover-has-links'] = 'true';
    lineElement.properties['data-hover-link-prefix'] = linkPrefix;
  }
  const tooltipChildren = createTooltipContent(annotation, enableLinks, linkPrefix);
  const tooltipElement = {
    type: 'element',
    tagName: 'span',
    properties: {
      className: [CUSTOM_HOVER_TOOLTIP_CLASS_NAME],
      'data-tooltip': 'true',
      'aria-hidden': 'true',
    },
    children: tooltipChildren,
  };
  lineElement.properties['data-tooltip-id'] = `hover-${Math.random().toString(36).substr(2, 9)}`;
  lineElement.children.push(tooltipElement);
}
function createTooltipContent(annotation, enableLinks, linkPrefix) {
  if (!annotation.hasLinks || !enableLinks) {
    return [{ type: 'text', value: annotation.content }];
  }
  const children = [];
  let lastIndex = 0;
  const linkRegex = /<span class="hover-link" data-anchor="([^"]+)">([^<]+)<\/span>/g;
  let match;
  while ((match = linkRegex.exec(annotation.content)) !== null) {
    if (match.index > lastIndex) {
      const beforeText = annotation.content.slice(lastIndex, match.index);
      if (beforeText) {
        children.push({ type: 'text', value: beforeText });
      }
    }
    const anchor = match[1];
    const linkText = match[2];
    if (anchor && linkText) {
      children.push({
        type: 'element',
        tagName: 'a',
        properties: {
          href: `${linkPrefix}#${anchor}`,
          className: ['hover-tooltip-link'],
          'data-anchor': anchor,
        },
        children: [{ type: 'text', value: linkText }],
      });
    }
    lastIndex = match.index + match[0].length;
  }
  if (lastIndex < annotation.content.length) {
    const remainingText = annotation.content.slice(lastIndex);
    if (remainingText) {
      children.push({ type: 'text', value: remainingText });
    }
  }
  return children;
}
