export const AI_CHAT_MESSAGE_OVERAGE_TIERS = [
    {
        min: 0,
        max: 499,
        price: 0.15,
        unit: 'USD',
    },
    {
        min: 500,
        max: 999,
        price: 0.145,
        unit: 'USD',
    },
    {
        min: 1000,
        max: 2999,
        price: 0.14,
        unit: 'USD',
    },
    {
        min: 3000,
        max: 9999,
        price: 0.135,
        unit: 'USD',
    },
    {
        min: 10000,
        max: Number.MAX_SAFE_INTEGER,
        price: 0.13,
        unit: 'USD',
    },
];
export function getChatPriceUsage(price) {
    // Calculate the usage for a given price using graduated tiers
    if (price <= 0) {
        return 0;
    }
    const tiers = AI_CHAT_MESSAGE_OVERAGE_TIERS;
    let remainingPrice = price;
    let totalUsage = 0;
    for (const tier of tiers) {
        // Calculate the tier capacity (same logic as getChatUsagePrice)
        const tierCapacity = tier.max === Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : tier.max - tier.min + 1; // +1 because ranges are inclusive
        // Calculate maximum price for this tier
        const tierMaxPrice = tierCapacity * tier.price;
        if (remainingPrice <= tierMaxPrice || tier.max === Number.MAX_SAFE_INTEGER) {
            // The remaining price can be fully satisfied by this tier
            const usageInThisTier = remainingPrice / tier.price;
            totalUsage += usageInThisTier;
            break;
        }
        else {
            // Use the full tier and continue to next tier
            totalUsage += tierCapacity;
            remainingPrice -= tierMaxPrice;
        }
    }
    return Math.floor(totalUsage);
}
export function getChatUsagePrice(usage) {
    // Calculate price using graduated billing tiers
    if (usage <= 0) {
        return 0;
    }
    const tiers = AI_CHAT_MESSAGE_OVERAGE_TIERS;
    let remainingUsage = usage;
    let totalPrice = 0;
    for (const tier of tiers) {
        // Calculate the tier capacity (how much usage this tier can handle)
        const tierCapacity = tier.max === Number.MAX_SAFE_INTEGER ? Number.MAX_SAFE_INTEGER : tier.max - tier.min + 1; // +1 because ranges are inclusive
        if (remainingUsage <= tierCapacity || tier.max === Number.MAX_SAFE_INTEGER) {
            // The remaining usage fits entirely in this tier
            totalPrice += remainingUsage * tier.price;
            break;
        }
        else {
            // Use the full tier capacity and continue to next tier
            totalPrice += tierCapacity * tier.price;
            remainingUsage -= tierCapacity;
        }
    }
    return totalPrice;
}
