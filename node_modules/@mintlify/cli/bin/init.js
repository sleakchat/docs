var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { select, input } from '@inquirer/prompts';
import { addLogs, addLog, SpinnerLog, removeLastLog } from '@mintlify/previewing';
import { docsConfigSchema } from '@mintlify/validation';
import AdmZip from 'adm-zip';
import fse from 'fs-extra';
import { Box, Text } from 'ink';
const sendOnboardingMessage = (installDir) => {
    addLogs(_jsx(Text, { bold: true, children: "Documentation Setup!" }), _jsx(Text, { children: "To see your docs run" }), _jsxs(Box, { children: [_jsx(Text, { color: "blue", children: "cd" }), _jsxs(Text, { children: [" ", installDir] })] }), _jsx(Text, { color: "blue", children: "mint dev" }));
};
export function init(installDir) {
    return __awaiter(this, void 0, void 0, function* () {
        yield fse.ensureDir(installDir);
        const dirContents = yield fse.readdir(installDir).catch(() => []);
        if (dirContents.length > 0) {
            const choice = yield select({
                message: `Directory ${installDir} is not empty. What would you like to do?`,
                choices: [
                    { name: 'Create in a subdirectory', value: 'subdir' },
                    { name: 'Overwrite current directory (may lose contents)', value: 'overwrite' },
                    { name: 'Cancel', value: 'cancel' },
                ],
            });
            if (choice === 'cancel') {
                return;
            }
            if (choice === 'subdir') {
                const subdir = yield input({
                    message: 'Subdirectory name:',
                    default: 'docs',
                });
                if (!subdir || subdir.trim() === '') {
                    throw new Error('Subdirectory name cannot be empty');
                }
                installDir = installDir === '.' ? subdir : `${installDir}/${subdir}`;
                yield fse.ensureDir(installDir);
            }
        }
        const defaultProject = installDir == '.' ? 'Mintlify' : installDir;
        const projectName = yield input({
            message: 'Project Name',
            default: defaultProject,
        });
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const themes = docsConfigSchema.options.map((option) => {
            return option.shape.theme._def.value;
        });
        const theme = yield select({
            message: 'Theme',
            choices: themes.map((t) => ({
                name: t,
                value: t,
            })),
        });
        addLog(_jsx(SpinnerLog, { message: "downloading starter template..." }));
        const response = yield fetch('https://github.com/mintlify/starter/archive/refs/heads/main.zip');
        const buffer = yield response.arrayBuffer();
        yield fse.writeFile(installDir + '/starter.zip', Buffer.from(buffer));
        removeLastLog();
        addLog(_jsx(SpinnerLog, { message: "extracting..." }));
        new AdmZip(installDir + '/starter.zip').extractAllTo(installDir, true);
        removeLastLog();
        yield fse.copy(installDir + '/starter-main', installDir, {
            overwrite: true,
            filter: (src) => !src.includes('starter-main/starter-main'),
        });
        yield fse.remove(installDir + '/starter.zip');
        yield fse.remove(installDir + '/starter-main');
        const docsJsonPath = installDir + '/docs.json';
        const docsConfig = yield fse.readJson(docsJsonPath);
        docsConfig.theme = theme;
        docsConfig.name = projectName;
        yield fse.writeJson(docsJsonPath, docsConfig, { spaces: 2 });
        sendOnboardingMessage(installDir);
    });
}
