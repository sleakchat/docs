import crypto from 'crypto';
import { promises as _promises } from 'fs';
import fse from 'fs-extra';
import matter from 'gray-matter';
const { stat } = _promises;
export const getFileExtension = (filename) => {
    return filename.substring(filename.lastIndexOf('.') + 1, filename.length) || filename;
};
export const isFileSizeValid = async (path, maxFileSizeInMb) => {
    const maxFileSizeBytes = maxFileSizeInMb * 1000000;
    const stats = await stat(path);
    return stats.size <= maxFileSizeBytes;
};
export function isError(obj) {
    return Object.prototype.toString.call(obj) === '[object Error]';
}
export const readJsonFile = async (path) => {
    const file = await fse.readFile(path, 'utf-8');
    return JSON.parse(file);
};
export const shouldRegenerateNavForPage = async (filename, contentStr, frontmatterHashes) => {
    try {
        const { data: currentFrontmatter } = matter(contentStr);
        const prevFrontmatterHash = frontmatterHashes.get(filename);
        const currentFrontmatterHash = crypto
            .createHash('md5')
            .update(JSON.stringify(currentFrontmatter))
            .digest('hex');
        if (!prevFrontmatterHash) {
            frontmatterHashes.set(filename, currentFrontmatterHash);
            return true;
        }
        if (currentFrontmatterHash !== prevFrontmatterHash) {
            frontmatterHashes.set(filename, currentFrontmatterHash);
            return true;
        }
        frontmatterHashes.set(filename, currentFrontmatterHash);
        return false;
    }
    catch (error) {
        console.warn(`Error parsing frontmatter for ${filename}, regenerating nav:`, error);
        return true;
    }
};
