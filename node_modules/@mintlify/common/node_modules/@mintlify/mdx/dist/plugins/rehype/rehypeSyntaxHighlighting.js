import { transformerTwoslash } from '@shikijs/twoslash';
import { toString } from 'hast-util-to-string';
import { createHighlighter } from 'shiki';
import { visit } from 'unist-util-visit';
import { shikiColorReplacements, DEFAULT_LANG_ALIASES, DEFAULT_LANG, DEFAULT_DARK_THEME, DEFAULT_LIGHT_THEME, DEFAULT_THEMES, DEFAULT_LANGS, SHIKI_TRANSFORMERS, } from './shiki-constants.js';
import { getTwoslashOptions, parseLineComment } from './twoslash/config.js';
import { getLanguage } from './utils.js';
let highlighterPromise = null;
async function getHighlighter() {
    if (!highlighterPromise) {
        highlighterPromise = createHighlighter({
            themes: DEFAULT_THEMES,
            langs: DEFAULT_LANGS,
        });
    }
    return highlighterPromise;
}
export const rehypeSyntaxHighlighting = (options = {}) => {
    return async (tree) => {
        const nodesToProcess = [];
        const themesToLoad = [];
        if (options.themes) {
            themesToLoad.push(options.themes.dark);
            themesToLoad.push(options.themes.light);
        }
        else if (options.theme) {
            themesToLoad.push(options.theme);
        }
        const highlighter = await getHighlighter();
        await Promise.all(themesToLoad
            .filter((theme) => !DEFAULT_THEMES.includes(theme) && theme !== 'css-variables')
            .map(async (theme) => await highlighter.loadTheme(theme)));
        visit(tree, 'element', (node, index, parent) => {
            const child = node.children[0];
            if (!parent ||
                index === undefined ||
                node.type !== 'element' ||
                node.tagName !== 'pre' ||
                !child ||
                child.type !== 'element' ||
                child.tagName !== 'code') {
                return;
            }
            // set the metadata of `node` (which is a pre element) to that of
            // `child` (which is the code element that likely contains all the metadata)
            if (!Object.keys(node.properties).length) {
                node.properties = child.properties;
            }
            if (!node.data) {
                node.data = child.data;
            }
            let lang = getLanguage(node, DEFAULT_LANG_ALIASES) ??
                getLanguage(child, DEFAULT_LANG_ALIASES) ??
                DEFAULT_LANG;
            if (!DEFAULT_LANGS.includes(lang)) {
                nodesToProcess.push(highlighter.loadLanguage(lang).then(() => {
                    traverseNode({ node, index, parent, highlighter, lang, options });
                }));
            }
            else {
                traverseNode({ node, index, parent, highlighter, lang, options });
            }
        });
        await Promise.all(nodesToProcess);
    };
};
function traverseNode({ node, index, parent, highlighter, lang, options, }) {
    try {
        let code = toString(node);
        const meta = node.data?.meta?.split(' ') ?? [];
        const twoslashIndex = meta.findIndex((str) => str.toLowerCase() === 'twoslash');
        const shouldUseTwoslash = twoslashIndex > -1;
        if (node.data && node.data.meta && shouldUseTwoslash) {
            meta.splice(twoslashIndex, 1);
            node.data.meta = meta.join(' ').trim() || undefined;
        }
        const linkMap = options.linkMap ?? new Map();
        if (shouldUseTwoslash) {
            const splitCode = code.split('\n');
            for (const [i, line] of splitCode.entries()) {
                const parsedLineComment = parseLineComment(line);
                if (!parsedLineComment)
                    continue;
                const { word, href } = parsedLineComment;
                linkMap.set(word, href);
                splitCode.splice(i, 1);
            }
            code = splitCode.join('\n');
        }
        const twoslashOptions = getTwoslashOptions({ linkMap });
        const hast = highlighter.codeToHast(code, {
            lang: lang ?? DEFAULT_LANG,
            meta: shouldUseTwoslash ? { __raw: 'twoslash' } : undefined,
            themes: {
                light: options.themes?.light ??
                    options.theme ??
                    (options.codeStyling === 'dark' ? DEFAULT_DARK_THEME : DEFAULT_LIGHT_THEME),
                dark: options.themes?.dark ?? options.theme ?? DEFAULT_DARK_THEME,
            },
            colorReplacements: shikiColorReplacements,
            tabindex: false,
            tokenizeMaxLineLength: 1000,
            transformers: [...SHIKI_TRANSFORMERS, transformerTwoslash(twoslashOptions)],
        });
        const codeElement = hast.children[0];
        if (!codeElement)
            return;
        const preChild = codeElement.children[0];
        node.data = node.data ?? {};
        codeElement.data = node.data;
        codeElement.properties.language = lang;
        if (preChild) {
            preChild.data = node.data;
            preChild.properties.language = lang;
        }
        parent.children.splice(index, 1, codeElement);
    }
    catch (err) {
        if (err instanceof Error && /Unknown language/.test(err.message)) {
            return;
        }
        throw err;
    }
}
