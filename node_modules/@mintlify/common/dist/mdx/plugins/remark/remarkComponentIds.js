import { slugifyWithCounter } from '@sindresorhus/slugify';
import { visit } from 'unist-util-visit';
import { slugify } from '../../../slugify.js';
import { createMdxJsxAttribute } from '../../lib/remark-utils.js';
import { getTableOfContentsTitle } from '../../lib/remark-utils.js';
export const HEADING_LEVELS = [1, 2, 3, 4];
export const AVOIDED_PAGE_MODES = ['custom', 'frame'];
export const CHILD_TAB_IDS_ATTRIBUTE = 'data-child-tab-ids';
export const CHILD_HEADING_IDS_ATTRIBUTE = 'data-child-heading-ids';
export const remarkComponentIds = (pageMetadata) => (tree) => {
    var _a;
    const slugifyFn = slugifyWithCounter();
    const tabSlugifyFn = slugifyWithCounter();
    const isAvoidedPageMode = AVOIDED_PAGE_MODES.includes((_a = pageMetadata === null || pageMetadata === void 0 ? void 0 : pageMetadata.mode) !== null && _a !== void 0 ? _a : '');
    visit(tree, 'heading', (node) => {
        if (isAvoidedPageMode)
            return;
        if (HEADING_LEVELS.includes(node.depth)) {
            const title = getTableOfContentsTitle(node);
            const slug = slugify(title, slugifyFn);
            const mdxJsxAttributes = [
                createMdxJsxAttribute('level', node.depth),
                createMdxJsxAttribute('id', slug),
            ];
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.attributes = mdxJsxAttributes;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.type = 'mdxJsxFlowElement';
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            node.name = 'Heading';
        }
    });
    const tabSlugs = new Map();
    const headingSlugs = new Map();
    const precomputeTabSlugs = (node) => {
        var _a, _b;
        if (node.type === 'mdxJsxFlowElement' && node.name === 'Tab') {
            const title = (_a = node.attributes.find((attr) => 'name' in attr && attr.name === 'title')) === null || _a === void 0 ? void 0 : _a.value;
            if (title && typeof title === 'string') {
                const slug = slugify(title, tabSlugifyFn);
                tabSlugs.set(node, slug);
            }
        }
        else if (node.type === 'mdxJsxFlowElement' && node.name === 'Heading') {
            const id = (_b = node.attributes.find((attr) => 'name' in attr && attr.name === 'id')) === null || _b === void 0 ? void 0 : _b.value;
            if (id && typeof id === 'string')
                headingSlugs.set(node, id);
        }
        if ('children' in node) {
            for (const child of node.children) {
                precomputeTabSlugs(child);
            }
        }
    };
    const processTabsRecursively = (node) => {
        if (node.type === 'mdxJsxFlowElement' && node.name === 'Tab') {
            const slug = tabSlugs.get(node);
            if (!slug)
                return;
            node.attributes.push(createMdxJsxAttribute('id', slug));
            const childTabIds = [];
            for (const child of node.children) {
                const childIds = collectDirectChildIds(child, 'Tab');
                childTabIds.push(...childIds);
            }
            if (childTabIds.length > 0) {
                try {
                    node.attributes.push(createMdxJsxAttribute(CHILD_TAB_IDS_ATTRIBUTE, JSON.stringify(childTabIds)));
                }
                catch (_a) { }
            }
            const childHeadingIds = collectDirectChildIds(node, 'Heading');
            if (childHeadingIds.length > 0) {
                try {
                    node.attributes.push(createMdxJsxAttribute(CHILD_HEADING_IDS_ATTRIBUTE, JSON.stringify(childHeadingIds)));
                }
                catch (_b) { }
            }
            for (const child of node.children) {
                processTabsRecursively(child);
            }
        }
        else if ('children' in node) {
            for (const child of node.children) {
                processTabsRecursively(child);
            }
        }
    };
    const collectDirectChildIds = (node, type) => {
        const childIds = [];
        if (node.type === 'mdxJsxFlowElement' && node.name === type) {
            const id = type === 'Tab' ? tabSlugs.get(node) : headingSlugs.get(node);
            if (id) {
                childIds.push(id);
            }
        }
        else if ('children' in node) {
            for (const child of node.children) {
                childIds.push(...collectDirectChildIds(child, type));
            }
        }
        return childIds;
    };
    precomputeTabSlugs(tree);
    processTabsRecursively(tree);
};
