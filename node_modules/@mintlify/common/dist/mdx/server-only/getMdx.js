var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { serialize } from '@mintlify/mdx/server';
import { getTailwindSelectors } from '../../css/tailwind.js';
import { getMDXOptions, remarkMdxRemoveJs, remarkExpandContent, remarkSplitCodeGroup, remarkSplitTabs, remarkValidateSteps, remarkValidateTabs, } from '../../index.js';
import { codeStylingToThemeOrThemes } from '../getCodeStyling.js';
import { createSnippetTreeMap } from './getMdx/snippets.js';
export function getMdx(_a) {
    return __awaiter(this, arguments, void 0, function* ({ path, content, metadata, snippets, subdomain, codeStyling, config, tailwindSelectors = undefined, pageType = 'default', trace = undefined, }) {
        const traceFn = trace !== null && trace !== void 0 ? trace : ((_name, fn) => fn());
        if (!tailwindSelectors)
            tailwindSelectors = yield traceFn('getMdx.getTailwindSelectors', () => __awaiter(this, void 0, void 0, function* () { return getTailwindSelectors({ content }); }));
        const snippetTreeMap = yield traceFn('getMdx.createSnippetTreeMap', () => __awaiter(this, void 0, void 0, function* () { return createSnippetTreeMap(snippets); }));
        const mdxOptionsData = {
            subdomain,
            snippetTreeMap,
            pageMetadata: metadata,
            config,
            codeStyling,
            tailwindSelectors,
        };
        let mdxExtracts = {};
        let plugins = [remarkValidateSteps, remarkValidateTabs];
        if (pageType === 'pdf') {
            plugins = [...plugins, remarkExpandContent, remarkSplitCodeGroup, remarkSplitTabs];
        }
        const mdxOptions = getMDXOptions({ data: mdxOptionsData, remarkPlugins: plugins, mdxExtracts });
        const mdxOptionsNoJs = getMDXOptions({
            data: mdxOptionsData,
            remarkPlugins: [remarkMdxRemoveJs, ...plugins],
        });
        const scope = {
            codeStyling,
            config,
            pageMetadata: metadata,
        };
        const { mdxSource, mdxSourceWithNoJs } = yield traceFn('getMdx.compileMdx.mainContent', () => __awaiter(this, void 0, void 0, function* () { return compileMdx(content, scope, mdxOptions, mdxOptionsNoJs, codeStyling, path, traceFn); }));
        const originalMdxExtracts = structuredClone(mdxExtracts);
        let panelMdxSource;
        let panelMdxSourceWithNoJs;
        if (mdxExtracts.panel && mdxExtracts.panel.content) {
            const panelContent = mdxExtracts.panel.content;
            const compiledMdx = yield traceFn('getMdx.compileMdx.panelContent', () => __awaiter(this, void 0, void 0, function* () { return compileMdx(panelContent, scope, mdxOptions, mdxOptionsNoJs, codeStyling, path, traceFn); }));
            panelMdxSource = compiledMdx.mdxSource;
            panelMdxSourceWithNoJs = compiledMdx.mdxSourceWithNoJs;
            // serializing mdx content with the panel content will remove the original mdxExtracts
            // so we need to restore the original mdxExtracts
            mdxExtracts = Object.assign(Object.assign({}, originalMdxExtracts), { codeExamples: mdxExtracts.codeExamples });
        }
        return {
            mdxExtracts,
            mdxSource,
            mdxSourceWithNoJs,
            panelMdxSource,
            panelMdxSourceWithNoJs,
        };
    });
}
function compileMdx(content, scope, mdxOptions, mdxOptionsNoJs, codeStyling, path, traceFn) {
    return __awaiter(this, void 0, void 0, function* () {
        const mdxSource = yield traceFn('compileMdx.withJs', () => __awaiter(this, void 0, void 0, function* () { return getCompiledMdxWithFallback(content, scope, mdxOptions, codeStyling, path, traceFn); }));
        const mdxSourceWithNoJs = yield traceFn('compileMdx.withoutJs', () => __awaiter(this, void 0, void 0, function* () { return getCompiledMdxWithFallback(content, scope, mdxOptionsNoJs, codeStyling, path, traceFn); }));
        return { mdxSource, mdxSourceWithNoJs };
    });
}
function getCompiledMdxWithFallback(source, scope, mdxOptions, codeStyling, path, traceFn) {
    return __awaiter(this, void 0, void 0, function* () {
        const themeOrThemes = codeStylingToThemeOrThemes(codeStyling);
        try {
            const result = yield traceFn('getCompiledMdxWithFallback.serialize', () => __awaiter(this, void 0, void 0, function* () {
                return serialize({
                    source,
                    scope,
                    mdxOptions,
                    syntaxHighlightingOptions: Object.assign({}, themeOrThemes),
                });
            }));
            if ('error' in result) {
                throw result.error;
            }
            result.scope = Object.assign(Object.assign({}, result.scope), { config: {} });
            return result;
        }
        catch (err) {
            if (path)
                console.log(`⚠️ Warning: MDX failed to parse page ${path}: `, err);
            // placeholder content for when there is a syntax error.
            const fallbackResult = yield traceFn('getCompiledMdxWithFallback.serialize.fallback', () => __awaiter(this, void 0, void 0, function* () {
                return serialize({
                    source: '🚧 A parsing error occured. Please contact the owner of this website. They can use the Mintlify CLI to test this website locally and see the errors that occur.',
                    scope,
                    mdxOptions,
                });
            }));
            if ('error' in fallbackResult) {
                throw fallbackResult.error;
            }
            fallbackResult.scope = Object.assign(Object.assign({}, fallbackResult.scope), { config: {} });
            return fallbackResult;
        }
    });
}
export { createSnippetTreeMap };
